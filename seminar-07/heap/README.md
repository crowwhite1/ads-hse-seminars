# Куча (Heap)

## Что такое куча

**Куча (Heap)** — это абстрактная структура данных, обычно реализуемая на основе массива, которая позволяет быстро получать (и удалять) **минимальный** или **максимальный** элемент.

Куча используется для реализации:

- **приоритетной очереди** (priority queue),
- сортировки кучей (**Heap Sort**),
- алгоритмов на графах (например, **Dijkstra**, **Prim**),
- задач вида «найти top-k элементов».

## Основная идея

Куча — это **почти полное бинарное дерево** (complete binary tree), в котором выполняется свойство кучи:

### 1) Max-Heap (макс-куча)
Для каждой вершины:
- значение родителя **>=** значений детей.

Следствие:
- **максимум** всегда лежит в корне.

### 2) Min-Heap (мин-куча)
Для каждой вершины:
- значение родителя **<=** значений детей.

Следствие:
- **минимум** всегда лежит в корне.

## Важное замечание

Куча **не является полностью отсортированной структурой**.

Например, в max-heap:
- корень — максимум,
- но остальные элементы не обязаны идти по убыванию.

То есть куча гарантирует только **локальный порядок** (между родителем и детьми), а не глобальный.


## Представление в массиве

Кучу удобно хранить в массиве без указателей.

Пусть элемент находится по индексу `i` (индексация с 0), тогда:

- **Родитель**: `(i - 1) // 2`
- **Левый ребенок**: `2 * i + 1`
- **Правый ребенок**: `2 * i + 2`

### Пример (max-heap)

Массив:
`[50, 30, 40, 10, 20, 35, 37]`

Дерево:
```text
        50
      /    \
    30      40
   /  \    /  \
 10  20  35  37
````


## Базовые операции

### 1. `peek()` / `top()`

Возвращает корневой элемент (min или max) без удаления.

* Для max-heap: максимум
* Для min-heap: минимум

**Сложность:** `O(1)`


### 2. `push(x)` / вставка

Добавляем элемент в конец массива, затем **поднимаем вверх** (`shift_up`, `sift_up`), пока свойство кучи не восстановится.

#### Идея:

* вставили в конец,
* сравниваем с родителем,
* если порядок нарушен — меняем местами,
* повторяем.

**Сложность:** `O(log n)`


### 3. `pop()` / извлечение корня

Удаляем корень (min/max):

1. Сохраняем корень как ответ.
2. Последний элемент переносим в корень.
3. Уменьшаем размер.
4. **Опускаем вниз** (`shift_down`, `sift_down`), пока свойство кучи не восстановится.

**Сложность:** `O(log n)`


### 4. `heapify()` / построение кучи из массива

Преобразует произвольный массив в кучу.

Делается снизу вверх:

* начинаем с последнего внутреннего узла (`n//2 - 1`)
* вызываем `shift_down(...)`

**Сложность:** `O(n)` (важно: не `O(n log n)`)


## Почему `heapify()` работает за `O(n)`, а не за `O(n log n)`?

Хотя `shift_down` в худшем случае `O(log n)`, не все вершины опускаются на большую глубину:

* листьев много, но они не двигаются,
* узлов выше меньше, но они могут двигаться глубже.

Суммарно получается **линейная сложность** `O(n)`.

## Стандартные служебные процедуры

### `shift_up(i)` (просеивание вверх)

Используется после вставки.

#### Для max-heap:

Пока `a[parent] < a[i]` — меняем местами.

#### Для min-heap:

Пока `a[parent] > a[i]` — меняем местами.


### `shift_down(i)` (просеивание вниз)

Используется после удаления корня и в `heapify()`.

#### Для max-heap:

* выбираем большего ребенка,
* если родитель меньше — меняем местами.

#### Для min-heap:

* выбираем меньшего ребенка,
* если родитель больше — меняем местами.


## Ассимптотика операций

| Операция     | Сложность  |
| ------------ | ---------- |
| `peek()`     | `O(1)`     |
| `push(x)`    | `O(log n)` |
| `pop()`      | `O(log n)` |
| `heapify()`  | `O(n)`     |
| `size()`     | `O(1)`     |
| `is_empty()` | `O(1)`     |


## Пример работы (Min-Heap)

Пусть в куче элементы:

`[2, 5, 3, 9, 7]`

Это min-heap (корень = минимум = `2`).

### `push(1)`

Добавили в конец:
`[2, 5, 3, 9, 7, 1]`

Поднимаем `1` вверх:

* `1 < 3` → swap
* `1 < 2` → swap

Результат:
`[1, 5, 2, 9, 7, 3]`

### `pop()`

Удаляем корень `1`, последний элемент `3` переносим в корень:

`[3, 5, 2, 9, 7]`

Опускаем вниз:

* сравниваем детей `5` и `2`, выбираем `2`
* `3 > 2` → swap

Результат:
`[2, 5, 3, 9, 7]`

Сложность:

* `O(n log n)`


## Плюсы и минусы

### Плюсы

* быстрый доступ к min/max (`O(1)`)
* быстрые вставка и удаление корня (`O(log n)`)
* компактная реализация через массив
* `heapify()` за `O(n)`

### Минусы

* не поддерживает быстрый поиск произвольного элемента (`O(n)`)
* не хранит элементы в отсортированном виде
* удаление/изменение элемента по индексу/значению требует дополнительной логики