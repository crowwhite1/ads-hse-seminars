# Алгоритм Дейкстры (Dijkstra)

## Что это такое

**Алгоритм Дейкстры** — это алгоритм поиска **кратчайших путей от одной стартовой вершины** до всех остальных вершин во **взвешенном графе**, если **все веса рёбер неотрицательные**.

Он отвечает на вопрос:

- как быстро добраться из вершины `s` в каждую вершину графа,
- какова длина кратчайшего пути,
- (при необходимости) как восстановить сам путь.


## Что алгоритм находит

Для заданной стартовой вершины `start` алгоритм вычисляет массив:

- `dist[v]` — длина кратчайшего пути от `start` до вершины `v`.

Если вершина недостижима, то:

- `dist[v] = INF`.


## Где применяется

Алгоритм Дейкстры используется в задачах:

- маршрутизации (карты, навигация),
- сетевых протоколах,
- логистике,
- графовых задачах на олимпиадах и собеседованиях,
- планировании перемещений/стоимостей,
- задачах на кратчайшие пути в играх и симуляциях.


## Когда можно использовать

Алгоритм Дейкстры корректен, если:

- граф взвешенный,
- веса рёбер **>= 0**.

### Важно
Если есть **отрицательные веса**, использовать Дейкстру **нельзя** (алгоритм может дать неправильный ответ).


## Идея алгоритма (интуитивно)

Алгоритм работает жадно:

1. Сначала знаем расстояние только до стартовой вершины: `0`.
2. Каждый раз выбираем вершину с **минимальным текущим расстоянием**.
3. Пытаемся улучшить расстояния до её соседей.
4. Повторяем, пока есть вершины для обработки.

### Почему это работает
Если все веса неотрицательные, то вершина с минимальным текущим расстоянием уже не может быть улучшена через какие-то «обходные» пути позже.


## Основные термины

### Граф
Граф состоит из:
- вершин (`0..n-1`)
- рёбер (связей между вершинами)

### Взвешенный граф
У каждого ребра есть вес `w` (стоимость, длина, время, цена и т.д.)

### Список смежности
Обычно граф хранят как:
- `adj[v] = [(to1, w1), (to2, w2), ...]`

Это означает: из `v` есть рёбра в `to1`, `to2`, ... с соответствующими весами.


## Структуры данных в Дейкстре

### 1) `dist`
Массив расстояний:
- изначально все `INF`,
- `dist[start] = 0`.

### 2) Куча / приоритетная очередь (min-heap)
Храним пары:
- `(текущее_расстояние, вершина)`

Это позволяет быстро получать вершину с минимальным расстоянием.


## Базовый алгоритм (с кучей)

1. Инициализируем `dist`
2. Кладём `(0, start)` в min-heap
3. Пока куча не пустая:
   - достаём `(cur_dist, v)`
   - если запись устарела — пропускаем
   - для каждого ребра `v -> to` с весом `w`:
     - `nd = cur_dist + w`
     - если `nd < dist[to]`, обновляем `dist[to]` и кладём `(nd, to)` в кучу


## Что такое "устаревшая запись" в куче

Во многих реализациях не делают `decrease-key`, а просто добавляют новую запись в кучу.

Например:
- сначала в кучу положили `(10, v)`
- потом нашли путь лучше и положили `(7, v)`

Тогда запись `(10, v)` становится **устаревшей**.

### Проверка
Когда достаём вершину:
- если `cur_dist != dist[v]`, значит это старая запись → пропускаем.

## Пример работы (пошагово)

Пусть граф:

* `0 -> 1 (4)`
* `0 -> 2 (1)`
* `2 -> 1 (2)`
* `1 -> 3 (1)`
* `2 -> 3 (5)`

Старт: `0`

### Инициализация

* `dist = [0, INF, INF, INF]`
* heap = `[(0, 0)]`


### Шаг 1

Достаём `(0, 0)`

Расслабляем рёбра из `0`:

* до `1`: `0 + 4 = 4` → `dist[1] = 4`
* до `2`: `0 + 1 = 1` → `dist[2] = 1`

Теперь:

* `dist = [0, 4, 1, INF]`
* heap содержит `(1,2)`, `(4,1)`


### Шаг 2

Достаём `(1, 2)`

Расслабляем рёбра из `2`:

* до `1`: `1 + 2 = 3` → лучше, чем `4`, обновляем
* до `3`: `1 + 5 = 6` → `dist[3] = 6`

Теперь:

* `dist = [0, 3, 1, 6]`
* в куче есть старая `(4,1)` и новая `(3,1)`, а также `(6,3)`


### Шаг 3

Достаём `(3, 1)`

Расслабляем:

* до `3`: `3 + 1 = 4` → лучше, чем `6`, обновляем

Теперь:

* `dist = [0, 3, 1, 4]`
* в куче: `(4,1)` (устарела), `(6,3)` (устарела позже), `(4,3)`


### Шаг 4

Достаём `(4,1)` → устаревшая запись, пропускаем


### Шаг 5

Достаём `(4,3)` → актуальная запись


### Шаг 6

Достаём `(6,3)` → устаревшая запись, пропускаем

Итог:

* `dist = [0, 3, 1, 4]`


## Что такое "расслабление" ребра (relaxation)

Это ключевая операция алгоритма.

Для ребра `v -> to` с весом `w` проверяем:

* можно ли улучшить путь до `to` через `v`.

Формула:

```text
if dist[v] + w < dist[to]:
    dist[to] = dist[v] + w
```

Это называется **релаксация (расслабление)** ребра.


## Сложность алгоритма

Пусть:

* `V` — число вершин
* `E` — число рёбер

### При использовании min-heap / priority queue

* Время: **O((V + E) log V)**
  Часто пишут как **O(E log V)** (для связных графов и практики)

* Память: **O(V + E)**
  (граф + массив расстояний + куча)

## Ограничения и частые ошибки

### 1) Отрицательные веса

Ошибка:

* запускать Дейкстру при `w < 0`

Почему плохо:

* жадность ломается, результат может быть неправильным.


### 2) Неправильный `INF`

`INF` должен быть достаточно большим:

* больше любой возможной длины пути.

Для языков:

* Python: часто `10**18` или `float('inf')`
* Java: `Long.MAX_VALUE` (с осторожностью при сложении)
* C++: `numeric_limits<long long>::max()`

### Важно про переполнение

Если `dist[v]` равно "бесконечности", то `dist[v] + w` может переполниться в фиксированных типах.

На практике в Дейкстре обычно это не проблема, если:

* мы достаём из кучи только достижимые вершины,
* `cur_dist` уже конечен.

## Восстановление пути (не только длины)

Если нужно получить не только расстояния, но и сам путь, добавляют массив:

* `parent[v]` — предыдущая вершина на кратчайшем пути.

При улучшении:

```text
if nd < dist[to]:
    dist[to] = nd
    parent[to] = v
    push (nd, to)
```

### Как восстановить путь до `target`

Идём назад:

* `target -> parent[target] -> parent[parent[target]] -> ...`
  до `start`, затем разворачиваем.