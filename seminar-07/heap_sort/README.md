# Сортировка кучей (Heap Sort)

## Что такое Heap Sort

**Heap Sort (сортировка кучей)** — это алгоритм сортировки, который использует структуру данных **куча (heap)**.

Идея:
1. Преобразовать массив в кучу.
2. Многократно извлекать максимальный (или минимальный) элемент и ставить его на правильную позицию.

Чаще всего используется **max-heap** для сортировки по возрастанию.


## Ключевая идея

Для сортировки по возрастанию:

- строим **max-heap** (максимум в корне),
- меняем корень с последним элементом,
- уменьшаем размер кучи,
- восстанавливаем свойство кучи (`shift_down` / `sift_down`),
- повторяем до конца.

В результате максимальные элементы постепенно уходят в конец массива.


## Почему это работает

В max-heap корень — это всегда **наибольший элемент** текущей кучи.

Если поставить его в конец массива, то:
- он уже находится на своем окончательном месте,
- остается отсортировать только оставшуюся часть массива.

После этого повторяем процесс для префикса меньшего размера.


## Ассимптотика

### Время
- Построение кучи (`heapify`) — **O(n)**
- `n - 1` извлечений с восстановлением — **O(n log n)**

Итоговая сложность:
- **O(n log n)** (в лучшем, среднем и худшем случаях)

### Память
- **O(1)** дополнительной памяти для in-place версии


## Свойства алгоритма

- **In-place**: да (классическая версия)
- **Стабильность**: нет (Heap Sort **нестабилен**)
- **Худший случай**: `O(n log n)` (в отличие от QuickSort, где может быть `O(n^2)`)


## Версии Heap Sort

### 1. In-place Heap Sort (классический)
Сортировка происходит прямо в исходном массиве.

Обычно используется **max-heap**:
- максимум переносится в конец,
- массив получается отсортированным по возрастанию.

### 2. Heap Sort с новым массивом
Можно построить, например, **min-heap** и многократно делать `pop()`, записывая элементы в новый массив.

- проще для понимания,
- но требует дополнительную память `O(n)`.


## Heap Sort через Max-Heap (по возрастанию)

### Шаги алгоритма
1. Построить max-heap из массива.
2. Для `end` от `n-1` до `1`:
   - поменять `a[0]` и `a[end]`,
   - восстановить кучу на диапазоне `[0, end)`.
3. Готово.

### Псевдокод
```text
heapify(a)

for end from n-1 down to 1:
    swap(a[0], a[end])
    shift_down(a, 0, end)
````
## Пошаговый пример (Max-Heap)

Исходный массив:

```text
[5, 1, 9, 3, 7]
```

### 1) Построили max-heap

```text
[9, 7, 5, 3, 1]
```

### 2) Меняем корень с последним

```text
[1, 7, 5, 3, 9]
```

`9` уже на своем месте.

Восстанавливаем кучу на первых 4 элементах:

```text
[7, 3, 5, 1, 9]
```

### 3) Меняем корень с `a[3]`

```text
[1, 3, 5, 7, 9]
```

Восстанавливаем кучу на первых 3 элементах:

```text
[5, 3, 1, 7, 9]
```

### 4) Повторяем

Итог:

```text
[1, 3, 5, 7, 9]
```
## Сравнение с другими сортировками

### Heap Sort vs QuickSort

* Heap Sort: всегда `O(n log n)`
* QuickSort: в среднем быстрее на практике, но худший случай `O(n^2)`

### Heap Sort vs Merge Sort

* Heap Sort: `O(1)` доп. память (in-place)
* Merge Sort: `O(n)` доп. память, но стабильный


## Плюсы и минусы

### Плюсы

* гарантированное `O(n log n)`
* in-place версия использует `O(1)` доп. памяти
* не зависит от "удачного" выбора опорного элемента

### Минусы

* нестабилен
* часто медленнее QuickSort на практике из-за худшей локальности памяти
* код сложнее, чем у простых сортировок (например, insertion sort)


## Когда использовать

Heap Sort полезен, когда:

* нужен гарантированный `O(n log n)` в худшем случае,
* важна экономия памяти,
* нужна реализация сортировки на основе кучи/priority queue.