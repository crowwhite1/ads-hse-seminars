# Односвязный список (Singly Linked List)

Односвязный список — это линейная структура данных, состоящая из **узлов (nodes)**, где каждый узел хранит:
- значение (data / value)
- ссылку **только на следующий узел**

В отличие от массива, элементы списка **не лежат в памяти подряд** — каждый узел существует отдельно и связан с другим через ссылки.


## Базовая идея

Каждый узел выглядит так:

```

[value | next] → [value | next] → [value | next] → None

```

- `head` — ссылка на первый элемент списка  
- последний элемент указывает на `None`  
- переход возможен **только вперёд**


## Чем односвязный список отличается от массива

| Критерий | Массив | Односвязный список |
|---------|--------|--------------------|
| Хранение в памяти | подряд | разбросано |
| Доступ по индексу | O(1) | O(n) |
| Вставка в начало | O(n) | O(1) |
| Вставка в конец | O(1)\* | O(1)\*\* |
| Удаление в начале | O(n) | O(1) |
| Память | компактно | больше накладных расходов |

\* если есть свободное место  
\*\* если храним `tail`


## Структура узла (Node)

Каждый узел содержит:

- `value` — хранимое значение
- `next` — ссылку на следующий узел

Логически:

```

Node:
value
next → Node | None

```


## Структура списка

Обычно список хранит:

- `head` — первый узел
- `tail` — последний узел (необязательно, но удобно)
- `size` — количество элементов

```

head → [10] → [20] → [30] → None
^
tail

````


## Основные операции

### 1. Проверка на пустоту

```text
is_empty()
````

Список пуст, если `head == None`.

**Сложность:** O(1)


### 2. Добавление в начало — `push_front`

Добавление нового узла **перед текущей головой**.

#### До:

```
head → [10] → [20] → None
```

#### push_front(5):

```
head → [5] → [10] → [20] → None
```

**Как это делается:**

1. Создаётся новый узел
2. `new.next = head`
3. `head = new`

**Сложность:** O(1)


### 3. Добавление в конец — `push_back`

Если хранится `tail`, операция быстрая.

#### До:

```
head → [10] → [20] → None
                     ^
                    tail
```

#### push_back(30):

```
head → [10] → [20] → [30] → None
                                 ^
                                tail
```

**Как это делается:**

1. Создаётся новый узел
2. `tail.next = new`
3. `tail = new`

**Сложность:** O(1)

> Если `tail` не хранить, придётся каждый раз проходить весь список → O(n)


### 4. Удаление из начала — `pop_front`

Удаляется первый элемент.

#### До:

```
head → [10] → [20] → [30] → None
```

#### pop_front() → возвращает `10`

```
head → [20] → [30] → None
```

**Как это делается:**

1. Сохраняем `head.value`
2. `head = head.next`

**Сложность:** O(1)


### 5. Поиск элемента — `find`

Последовательный обход списка.

```text
find(20) → True
find(99) → False
```

**Как работает:**

* начинаем с `head`
* сравниваем значения
* двигаемся по `next`

**Сложность:** O(n)


### 6. Удаление первого вхождения — `remove_first`

Удаляется **первый найденный** элемент с заданным значением.

#### Пример:

```
[10] → [20] → [30] → [20] → None
```

`remove_first(20)`:

```
[10] → [30] → [20] → None
```

**Особые случаи:**

* удаляется `head`
* удаляется `tail`
* элемент не найден

**Сложность:** O(n)


### 7. Преобразование в список — `to_list`

Полезно для:

* отладки
* тестирования
* визуализации

```
[10, 20, 30]
```

**Сложность:** O(n)


## Итерация по списку

Односвязный список удобно итерировать **слева направо**:

```
for x in list:
    ...
```

Под капотом:

* начинаем с `head`
* каждый шаг: `cur = cur.next`


## Пример полного сценария работы

```python
lst = SinglyLinkedList()

lst.push_back(10)
lst.push_back(20)
lst.push_front(5)

print(lst.to_list())   # [5, 10, 20]

lst.pop_front()        # 5
lst.remove_first(20)

print(lst.to_list())   # [10]
```


## Ограничения односвязного списка

Важно понимать, чего **нельзя или неудобно** делать:

❌ нельзя идти назад <br>
❌ нельзя получить элемент по индексу за O(1)<br>
❌ удаление произвольного узла без ссылки на предыдущий — невозможно<br>


## Где используется односвязный список

* реализация **stack**, **queue**
* хранение потоков данных
* задачи, где важны:

  * частые вставки/удаления
  * работа с началом структуры
* низкоуровневые структуры (ядра, драйверы)
* функциональные языки (списки — базовая структура)


## Когда стоит использовать

Используй односвязный список, если:

✅ нужны частые вставки/удаления
✅ не нужен быстрый доступ по индексу
✅ структура растёт/уменьшается динамически

Не используй, если:

❌ нужен случайный доступ
❌ важна минимальная память
❌ нужен быстрый поиск по индексу


## Сравнение с двусвязным списком

| Критерий         | Односвязный | Двусвязный  |
| ---------------- | ----------- | ----------- |
| Ссылки           | next        | prev + next |
| Память           | меньше      | больше      |
| Движение назад   | ❌           | ✅           |
| Удаление с конца | сложно      | легко       |
| Реализация       | проще       | сложнее     |


## Итог

Односвязный список — это:

* простая и фундаментальная структура данных
* основа для многих других структур
* отличный инструмент для обучения работе с указателями и ссылками

Ключевая идея:

> **каждый элемент знает только о следующем**

Понимание односвязного списка — обязательный шаг к уверенной работе с алгоритмами и структурами данных.
