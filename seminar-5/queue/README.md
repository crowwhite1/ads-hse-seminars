# Очередь (Queue) — структура данных FIFO

Очередь (queue) — это структура данных, которая работает по принципу **FIFO** (*First In, First Out*):  
**первым пришёл — первым ушёл**.

Простой пример из жизни — очередь в магазине:  
человек, который встал первым, обслуживается первым.



## Основные операции очереди

Очередь обычно поддерживает 4 базовые операции:

- **enqueue(x)** — добавить элемент `x` в конец очереди
- **dequeue()** — удалить и вернуть элемент из начала очереди
- **peek() / front()** — посмотреть первый элемент без удаления
- **is_empty()** — проверить, пуста ли очередь

Дополнительно:
- **size() / len(queue)** — узнать количество элементов



## Как устроена очередь

Есть два основных способа реализации:

1. На **односвязном списке**
2. На **динамическом массиве**

Обе реализации обеспечивают:
- `enqueue` — O(1)
- `dequeue` — O(1)



# 1) Очередь на односвязном списке

## Идея

Мы храним:

- `head` — начало очереди (первый элемент)
- `tail` — конец очереди (куда добавляются новые элементы)
- `_size` — количество элементов

Каждый узел `Node` хранит:
- `data` — значение
- `next` — ссылку на следующий узел



## enqueue(value) — как работает

**Что происходит:**

1. Создаём новый узел
2. Если очередь пуста:
   - `head = tail = node`
3. Иначе:
   - `tail.next = node`
   - `tail = node`
4. Увеличиваем размер



### Схема

До `enqueue(30)`:

```

head → [10] → [20] → None
^
tail

```

После `enqueue(30)`:

```

head → [10] → [20] → [30] → None
^
tail

```

**Сложность:** `O(1)`



## dequeue() — как работает

**Что происходит:**

1. Если очередь пуста — ошибка
2. Берём `head.data`
3. Сдвигаем `head = head.next`
4. Если `head == None`:
   - `tail = None`
5. Уменьшаем `_size`
6. Возвращаем значение



### Схема

До `dequeue()`:

```

head → [10] → [20] → [30] → None

```

После:

```

head → [20] → [30] → None

```

Возвращаем: `10`

**Сложность:** `O(1)`



## peek() — как работает

Просто возвращаем:

```

head.data

````

Без удаления элемента.

**Сложность:** `O(1)`



## Пример использования (связный список)

```python
q = Queue()

q.enqueue(10)
q.enqueue(20)
q.enqueue(30)

print(q.peek())      # 10
print(q.dequeue())   # 10
print(q.dequeue())   # 20

print(len(q))        # 1
print(q.to_list())   # [30]
````



## Плюсы и минусы (список)

**Плюсы:**

* все операции строго `O(1)`
* не нужно расширять массив

**Минусы:**

* каждый элемент — отдельный объект
* больше накладных расходов по памяти



# 2) Очередь на динамическом массиве

## Идея

Мы храним:

* `_data` — массив
* `_front` — индекс начала очереди
* `_size` — количество элементов

Важное правило:

* элементы лежат подряд, начиная с `_front`
* если массив заполнен — делаем расширение (`resize`)



## enqueue(value) — как работает

**Что происходит:**

1. Проверяем:

   ```
   if _front + _size == len(_data)
   ```

   Если да — массив заполнен → делаем resize
2. Записываем элемент в:

   ```
   index = _front + _size
   ```
3. Увеличиваем `_size`



### Пример

Начальное состояние:

```
_data = [10, 20, None, None]
_front = 0
_size = 2
```

`enqueue(30)`:

```
_data = [10, 20, 30, None]
_front = 0
_size = 3
```



## Когда происходит расширение

Если массив заполнен:

До:

```
_data = [10, 20, 30, 40]
_front = 0
_size = 4
```

При `enqueue(50)`:

1. Создаётся новый массив в 2 раза больше:

```
[None, None, None, None, None, None, None, None]
```

2. Копируются элементы:

```
[10, 20, 30, 40, None, None, None, None]
```

3. Добавляется новый элемент:

```
[10, 20, 30, 40, 50, None, None, None]
```



## dequeue() — как работает

**Что происходит:**

1. Если пусто — ошибка
2. Берём `_data[_front]`
3. Очищаем ячейку
4. Увеличиваем `_front`
5. Уменьшаем `_size`
6. Если `_size == 0`:

   * `_front = 0`



### Пример

До:

```
_data = [10, 20, 30, None]
_front = 0
_size = 3
```

`dequeue()`:

После:

```
_data = [None, 20, 30, None]
_front = 1
_size = 2
```

Возвращаем: `10`



## peek() — как работает

Возвращаем:

```
_data[_front]
```

**Сложность:** `O(1)`



## Пример использования (массив)

```python
q = Queue(capacity=2)

q.enqueue("a")
q.enqueue("b")
q.enqueue("c")  # здесь произойдёт resize

print(q.peek())     # "a"
print(q.dequeue())  # "a"
print(q.dequeue())  # "b"

print(len(q))       # 1
print(q.to_list())  # ["c"]
```



## Почему расширение делают в 2 раза

Если увеличивать массив на 1 элемент каждый раз:

* каждая вставка будет требовать копирования
* сложность станет `O(n)` на каждую операцию

Если увеличивать в 2 раза:

* копирование происходит редко
* средняя сложность `enqueue` становится
  **амортизированно O(1)**

# Сравнение реализаций

| Критерий | Связный список  | Динамический массив  |
| -------- | --------------- | -------------------- |
| enqueue  | O(1)            | амортизированно O(1) |
| dequeue  | O(1)            | O(1)                 |
| память   | больше объектов | компактнее           |
| resize   | не нужен        | иногда O(n)          |

# Где используется очередь

Очереди применяются в:

* планировании задач (task scheduling)
* обработке запросов к серверу
* BFS (поиск в ширину)
* очередях печати
* симуляциях процессов
* потоковых системах

# Итог

Очередь — фундаментальная структура данных, работающая по принципу **FIFO**.

Главная идея:

* добавляем в конец
* удаляем из начала
* поэтому основные операции выполняются за `O(1)`

Две реализации (на списке и массиве) дают одинаковое поведение, но отличаются внутренней организацией и расходом памяти.
