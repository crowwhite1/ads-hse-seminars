# Двусвязный список (Doubly Linked List)

Двусвязный список — это линейная структура данных, состоящая из **узлов (nodes)**, где каждый узел хранит:
- значение (data / value)
- ссылку на **предыдущий** узел
- ссылку на **следующий** узел

Это расширение идеи односвязного списка, в котором движение возможно **в обе стороны**.


## Базовая идея

Каждый узел выглядит так:

```

None <- [prev | value | next] <-> [prev | value | next] <-> [prev | value | next] -> None

```

- `head` — первый элемент списка  
- `tail` — последний элемент списка  
- `prev` у `head` равен `None`  
- `next` у `tail` равен `None`  


## Отличие от односвязного списка

| Критерий | Односвязный список | Двусвязный список |
|---------|-------------------|-------------------|
| Ссылки в узле | next | prev + next |
| Движение назад | ❌ | ✅ |
| Удаление с конца | O(n) | O(1) |
| Вставка с конца | O(1)\* | O(1) |
| Память | меньше | больше |
| Реализация | проще | сложнее |

\* без хранения `tail`


## Структура узла (Node)

Каждый узел содержит:

- `value` — хранимое значение
- `prev` — ссылка на предыдущий узел
- `next` — ссылка на следующий узел

Логически:

```

Node:
prev -> Node | None
value
next -> Node | None

```


## Структура списка

Обычно список хранит:

- `head` — первый элемент
- `tail` — последний элемент
- `size` — количество элементов

```

None <- [10] <-> [20] <-> [30] -> None
^                               ^
head                            tail

````


## Основные операции

### 1. Проверка на пустоту

```text
is_empty()
````

Список пуст, если `size == 0`.

**Сложность:** O(1)


### 2. Добавление в начало — `push_front`

Добавляет новый узел **перед текущей головой**.

#### До:

```
head -> [10] <-> [20] <-> [30]
```

#### push_front(5):

```
head -> [5] <-> [10] <-> [20] <-> [30]
```

**Как это делается:**

1. Создаётся новый узел
2. `new.next = head`
3. `head.prev = new`
4. `head = new`

**Сложность:** O(1)


### 3. Добавление в конец — `push_back`

Добавляет новый узел **после текущего хвоста**.

#### push_back(40):

```
[5] <-> [10] <-> [20] <-> [30] <-> [40] <- tail
```

**Как это делается:**

1. Создаётся новый узел
2. `new.prev = tail`
3. `tail.next = new`
4. `tail = new`

**Сложность:** O(1)


### 4. Удаление из начала — `pop_front`

Удаляет первый элемент списка.

#### До:

```
head -> [5] <-> [10] <-> [20]
```

#### pop_front() → возвращает `5`:

```
head -> [10] <-> [20]
```

**Как это делается:**

1. Сохраняем `head.value`
2. `head = head.next`
3. `head.prev = None`

**Сложность:** O(1)


### 5. Удаление с конца — `pop_back`

Удаляет последний элемент списка.

#### До:

```
[10] <-> [20] <-> [30] <- tail
```

#### pop_back() → возвращает `30`:

```
[10] <-> [20]
```

**Как это делается:**

1. Сохраняем `tail.value`
2. `tail = tail.prev`
3. `tail.next = None`

**Сложность:** O(1)


### 6. Поиск элемента — `find`

Линейный обход списка.

```text
find(20) → True
find(99) → False
```

**Сложность:** O(n)


### 7. Удаление первого вхождения — `remove_first`

Удаляет **первый найденный** узел со значением `value`.

#### Пример:

```
[10] <-> [20] <-> [30] <-> [20]
```

`remove_first(20)`:

```
[10] <-> [30] <-> [20]
```

**Как это делается:**

* перенаправляются ссылки `prev` и `next` соседних узлов
* `head` или `tail` обновляются при необходимости

**Сложность:** O(n)


### 8. Преобразование в список — `to_list`

Используется для:

* отладки
* тестов
* визуализации

```
[10, 20, 30]
```

**Сложность:** O(n)


## Итерация по списку

Двусвязный список можно итерировать **слева направо**:

```
cur = head
while cur != None:
    cur = cur.next
```

И (при необходимости) **справа налево**:

```
cur = tail
while cur != None:
    cur = cur.prev
```


## Пример полного сценария

```python
lst = DoublyLinkedList()

lst.push_back(10)
lst.push_back(20)
lst.push_front(5)

print(lst.to_list())   # [5, 10, 20]

lst.pop_back()         # 20
lst.remove_first(10)

print(lst.to_list())   # [5]
```


## Ограничения и особенности

❌ больше памяти (две ссылки на узел)<br>
❌ сложнее реализация и больше мест для ошибок<br>
✅ быстрые операции с обоих концов<br>
✅ можно легко удалять элементы из середины<br>


## Где используется двусвязный список

* реализация **deque**
* LRU-кэш (список + hashmap)
* навигация назад/вперёд (браузеры)
* плейлисты
* редакторы (undo/redo)
* системные и низкоуровневые структуры


## Сравнение: массив vs двусвязный список

| Операция          | Массив    | Двусвязный список |
| ----------------- | --------- | ----------------- |
| Доступ по индексу | O(1)      | O(n)              |
| Вставка в начало  | O(n)      | O(1)              |
| Вставка в конец   | O(1)*     | O(1)              |
| Удаление с конца  | O(1)      | O(1)              |
| Память            | компактно | больше            |


## Когда использовать двусвязный список

Используй, если:

✅ нужны быстрые операции с обоих концов<br>
✅ часто удаляются элементы из середины<br>
✅ важна возможность двигаться в обе стороны<br>

Не стоит использовать, если:

❌ нужен быстрый доступ по индексу<br>
❌ критична память<br>
❌ структура почти не меняется<br>


## Итог

Двусвязный список — это:

* логичное развитие односвязного списка
* фундамент для deque и LRU-кэшей
* структура, где **скорость операций важнее памяти**

Ключевая идея:

> **каждый элемент знает и о следующем, и о предыдущем**
