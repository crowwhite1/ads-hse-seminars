# Стек (Stack) — структура данных LIFO

Стек (stack) — это структура данных, которая работает по принципу **LIFO** (*Last In, First Out*):  
**последним положили — первым достали**.

Пример из жизни: стопка тарелок. Новую тарелку кладём сверху и берём тоже сверху.



## Основные операции стека

Стек обычно поддерживает 4 базовые операции:

- **push(x)** — положить элемент `x` на вершину стека
- **pop()** — снять и вернуть верхний элемент
- **peek() / top()** — посмотреть верхний элемент (не удаляя)
- **is_empty()** — проверить, пуст ли стек

Дополнительно часто есть:
- **size() / len(stack)** — узнать количество элементов

## Как устроен стек внутри

Есть два популярных способа реализации:

1. **На односвязном списке** (каждый элемент — узел, храним ссылку на вершину)
2. **На динамическом массиве** (в Python — список), где вершина — это последний занятый индекс

Обе реализации дают операции `push/pop/peek` за **O(1)** (в среднем).



# 1) Стек на односвязном списке

## Идея

Мы храним:
- `top` — ссылку на верхний узел (вершину)
- `_size` — количество элементов

Каждый узел `Node` хранит:
- `data` — значение
- `next` — ссылку на следующий узел (элемент под ним)

Вершина стека — это `top`.  
Элемент под вершиной — это `top.next`.

## push(data) — как работает

**Что происходит:**
1. Создаём новый узел `Node(data)`
2. Новый узел указывает на старую вершину (`next = top`)
3. Обновляем `top` на новый узел

**Схема:**

До `push(30)`:

```

top → [20] → [10] → None

```

После `push(30)`:

```

top → [30] → [20] → [10] → None

```

**Сложность:** `O(1)`  
(мы делаем фиксированное число действий, не зависящее от размера стека)



## pop() — как работает

**Что происходит:**
1. Если стек пуст — ошибка
2. Берём `top.data`
3. Сдвигаем `top = top.next`
4. Уменьшаем `_size`
5. Возвращаем сохранённое значение

**Схема:**

До `pop()`:

```

top → [30] → [20] → [10] → None

```

После `pop()`:

```

top → [20] → [10] → None

````

Возвращаем: `30`

**Сложность:** `O(1)`



## peek() — как работает

**Что происходит:**
- Если пусто — ошибка
- Иначе возвращаем `top.data`, но ничего не меняем

**Сложность:** `O(1)`



## Пример использования (список)

```python
s = Stack()

s.push(10)
s.push(20)
s.push(30)

print(s.peek())  # 30
print(s.pop())   # 30
print(s.pop())   # 20

print(s.is_empty())  # False
print(len(s))        # 1
print(s.to_list())   # [10]
````



## Плюсы и минусы (список)

**Плюсы:**

* `push/pop` всегда `O(1)` без амортизаций
* не нужно расширять массив

**Минусы:**

* каждый узел — отдельный объект → больше накладных расходов по памяти
* аллокации объектов могут быть дороже, чем работа с массивом



# 2) Стек на динамическом массиве (с ручным расширением)

## Идея

Мы храним:

* `_data` — массив фиксированной ёмкости
* `_size` — сколько элементов реально лежит в стеке (и индекс вершины = `_size - 1`)

Важно:

* Мы **не используем** `append/pop` массива, а кладём по индексу.
* Если массив заполнен, делаем `_resize()` — создаём новый массив побольше и копируем элементы.



## push(value) — как работает

**Что происходит:**

1. Если `_size == len(_data)` → массив заполнен → увеличиваем ёмкость в 2 раза
2. Пишем элемент в `_data[_size]`
3. Увеличиваем `_size`

**Пример:**

Пусть `capacity = 4`, а сейчас в стеке 3 элемента:

```
_data = [10, 20, 30, None]
_size = 3
```

`push(40)`:

```
_data = [10, 20, 30, 40]
_size = 4
```

`push(50)` — массив переполнен, нужно расширение:

До расширения:

```
_data = [10, 20, 30, 40]
_size = 4
```

После `_resize(8)`:

```
_data = [10, 20, 30, 40, None, None, None, None]
_size = 4
```

Потом кладём `50`:

```
_data = [10, 20, 30, 40, 50, None, None, None]
_size = 5
```



## Почему расширение делают в 2 раза

Если расширять на 1 каждый раз, то вставка станет дорогой:
при каждом `push` нужно будет копировать весь массив.

Если же увеличивать в 2 раза, то копирование происходит редко, и средняя стоимость `push` — **амортизированно O(1)**.



## pop() — как работает

**Что происходит:**

1. Если пусто — ошибка
2. Уменьшаем `_size`
3. Берём `value = _data[_size]`
4. Стираем ссылку `_data[_size] = None` (чтобы не держать объект в памяти)
5. Возвращаем значение

До:

```
_data = [10, 20, 30, None]
_size = 3
```

`pop()`:

После:

```
_data = [10, 20, None, None]
_size = 2
```

Вернули: `30`

**Сложность:** `O(1)`



## peek() — как работает

Возвращаем `_data[_size - 1]` без удаления.

**Сложность:** `O(1)`



## Пример использования (массив)

```python
s = Stack(capacity=2)

s.push("a")
s.push("b")

print(s.peek())  # "b"

s.push("c")      # тут произойдёт расширение массива

print(s.pop())   # "c"
print(s.pop())   # "b"

print(len(s))    # 1
print(s.to_list())  # ["a"]
```



## Плюсы и минусы (массив)

**Плюсы:**

* обычно быстрее на практике (меньше объектов и ссылок)
* компактнее по памяти на больших объёмах данных

**Минусы:**

* иногда `push` вызывает расширение → приходится копировать массив (`O(n)`), но редко
* нужно вручную писать логику `_resize`



# Сравнение двух реализаций

| Критерий   | Связный список                   | Динамический массив                               |
| - | -- | - |
| `push`     | `O(1)`                           | амортизированно `O(1)` (иногда `O(n)` при resize) |
| `pop`      | `O(1)`                           | `O(1)`                                            |
| `peek`     | `O(1)`                           | `O(1)`                                            |
| Память     | больше накладных расходов (узлы) | обычно компактнее                                 |
| Реализация | проще логика, но больше объектов | нужно resize, но меньше объектов                  |



# Где стек используется

* отмена действий (**undo**)
* обход графов/деревьев (**DFS**)
* проверка скобок и парсинг выражений
* вычисление выражений (RPN / postfix)
* поддержка вызовов функций (**call stack**)


# Итог

Стек — простая, но очень важная структура данных.
Его главная идея: **работаем только с вершиной**, поэтому основные операции быстрые (`O(1)`).

Две реализации — через связный список и через динамический массив — дают одинаковое поведение, но отличаются внутренней организацией и компромиссами по памяти/скорости.