# DFS (Depth-First Search) — поиск в глубину

DFS (поиск в глубину) — базовый алгоритм обхода графа, который “идёт как можно глубже”, а когда упирается — откатывается назад и продолжает обход из предыдущих вершин.

Обычно DFS применяют к графу, заданному **списком смежности** `g`, где `g[v]` — список соседей вершины `v`.



## Идея алгоритма

Есть массив `visited[]` (посещена ли вершина).  
Запускаем DFS из стартовой вершины `s`:

1. Помечаем `s` посещённой.
2. Для каждого соседа `to`:
   - если `to` ещё не посещён — запускаем DFS(to).

В итоге DFS обходит все вершины, **достижимые** из `s`.



## Псевдокод (рекурсия)

```text
dfs(v):
    visited[v] = true
    for each to in g[v]:
        if not visited[to]:
            dfs(to)
````



## Две реализации DFS

### 1) Рекурсивный DFS

Плюсы:

* максимально простой и читаемый
* естественно соответствует идее “углубления”

Минусы:

* может упасть по переполнению стека вызовов, если граф большой или “цепочкой”
* в некоторых платформах/контестах глубина рекурсии ограничена

Когда использовать:

* небольшие графы
* задачи, где глубина гарантированно не слишком большая
* учебные/поясняющие реализации



### 2) Итеративный DFS (через стек)

Плюсы:

* не использует рекурсию → нет риска переполнения стека
* легко контролировать память и поведение

Минусы:

* чуть более “шумный” код
* если нужен “тот же порядок”, что у рекурсивного DFS, надо аккуратно пушить соседей

Когда использовать:

* большие графы (например, `n` до 2e5)
* любые задачи, где рекурсия может быть опасной



## Важное про порядок обхода

DFS **не гарантирует уникального порядка** обхода.
Порядок зависит от:

* порядка соседей в списке смежности
* в итеративной версии — от того, в каком порядке вы кладёте соседей в стек

Если хочется, чтобы итеративный DFS шёл примерно “как рекурсивный”, обычно:

* соседи кладутся в стек **в обратном порядке**.

Но чаще всего в задачах **порядок обхода не важен**, важен только факт достижимости/компоненты/наличия цикла.



## Сложность

### Время

DFS проходит по каждой вершине и ребру максимум ограниченное число раз.

* Для списка смежности: **O(n + m)**
  где `n` — число вершин, `m` — число рёбер.

### Память

* `visited`: **O(n)**
* рекурсивный DFS: + стек вызовов **O(h)**, где `h` — глубина DFS (в худшем `O(n)`)
* итеративный DFS: + явный стек **O(h)** (в худшем тоже `O(n)`)



## На каких графах работает

DFS применим к:

* **неориентированным** и **ориентированным** графам
* взвешенным и невзвешенным (веса DFS игнорирует, это не кратчайший путь)
* графам с петлями/кратными рёбрами (просто надо помнить про `visited`)



## Частые применения DFS

### 1) Проверка достижимости

Можно ли попасть из `s` в `t`?

Идея: запустить DFS(s) и проверить `visited[t]`.



### 2) Компоненты связности (неориентированный граф)

Сколько компонент связности?

Идея:

* пройти по всем вершинам
* если `visited[v] == false`, запускаем DFS(v) и увеличиваем счётчик компонент



### 3) Размер компоненты

Сколько вершин в компоненте вершины `s`?

Идея: запустить DFS(s), посчитать количество отмеченных.



### 4) Поиск цикла

**Неориентированный граф**:

* DFS с параметром `parent`
* если видим ребро в уже посещённую вершину, которая не `parent` → цикл

**Ориентированный граф**:

* используют 3 цвета: `0`=не посещён, `1`=в стеке, `2`=вышли
* если идём в вершину цвета `1` → найден обратный ребро → цикл



### 5) Топологическая сортировка (ориентированный ациклический граф, DAG)

Идея:

* DFS
* добавлять вершину в ответ при выходе из неё (postorder)
* потом развернуть список


