# BFS (поиск в ширину)

BFS (Breadth-First Search) — это алгоритм обхода графа “по слоям”:  
сначала посещаются все вершины на расстоянии 1 от старта, затем на расстоянии 2, и т.д.

Ключевая идея: используется **очередь (queue)**, которая хранит “фронт” обхода.



## Когда использовать BFS

BFS — основной инструмент, когда нужно:

- **обойти/проверить достижимость** вершин из одной вершины
- **найти кратчайшие пути в невзвешенном графе** (или когда все веса одинаковые)
- **посчитать расстояния (кол-во рёбер)** от стартовой вершины до всех достижимых
- **проверить двудольность графа** (через раскраску по слоям)
- найти **компоненту связности**, если запускать BFS из непосещённых вершин
- задачи на **решётке (grid)**: кратчайший путь в лабиринте, волна и т.п.



## Как работает BFS

1) Кладём стартовую вершину в очередь и помечаем её посещённой.  
2) Пока очередь не пуста:
   - достаём вершину `v`
   - смотрим всех её соседей `to`
   - если сосед ещё не посещён → помечаем и кладём в очередь

Важно: **вершина попадает в очередь максимум один раз**, если правильно ставить `visited` в момент добавления в очередь.



## BFS и кратчайший путь

В **невзвешенном графе** BFS гарантирует, что вершина впервые посещается по **кратчайшему пути** от старта (минимум рёбер).

Обычно для этого хранят:
- `dist[v]` — расстояние (количество рёбер) от старта до `v`
- `parent[v]` — откуда пришли (для восстановления пути)



## Псевдокод

```text
BFS(start):
    queue q
    visited[start] = true
    dist[start] = 0
    q.push(start)

    while q not empty:
        v = q.pop()
        for each to in adj[v]:
            if not visited[to]:
                visited[to] = true
                dist[to] = dist[v] + 1
                parent[to] = v
                q.push(to)
````



## Ассимптотика (сложность)

Зависит от представления графа.

### Если граф задан списком смежности

* **Время:** `O(V + E)`

  * каждую вершину извлекаем из очереди максимум 1 раз → `O(V)`
  * каждое ребро просматриваем максимум 1–2 раза (в зависимости от типа графа) → `O(E)`
* **Память:** `O(V)`

  * массив `visited`, `dist`, `parent` и очередь в худшем случае содержат до `V` вершин

### Если граф задан матрицей смежности

* **Время:** `O(V^2)`

  * для каждой вершины приходится просматривать всю строку матрицы (`V`)
* **Память:** `O(V^2)` на хранение матрицы + `O(V)` на BFS структуры



## Типичные ошибки

1. **Ставить visited слишком поздно**

   * неверно: помечать `visited` при извлечении из очереди
   * правильно: помечать **когда добавили в очередь**, иначе одна вершина может попасть туда много раз

2. **Путаница с направленностью**

   * в ориентированном графе BFS идёт только по исходящим рёбрам
   * в неориентированном нужно добавить ребро в обе стороны (или правильно читать матрицу)

3. **Забыть обработать старт**

   * `visited[start] = true`, `dist[start] = 0`, положить в очередь



## Варианты BFS

* **Multi-source BFS**: стартуем сразу из нескольких вершин (кладём их в очередь изначально)
* **BFS на grid**: соседи — клетки (4/8 направлений)
* **BFS для восстановления пути**: хранить `parent[]`
* **0-1 BFS**: если веса рёбер 0 или 1 (используется deque)
* **BFS по состояниям**: вершина — это состояние (например, “позиция + маска”)