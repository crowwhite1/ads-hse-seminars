# Quick Sort (быстрая сортировка)

В этой папке — 3 реализации quick sort разной “серьёзности”:
1) **Медленная** (функциональный стиль: `left/mid/right`)
2) **Обычная** (in-place + 3-путевое разбиение, pivot детерминированный по центру)
3) **Максимально оптимизированная** (median-of-three pivot + 3-way partition + итеративно + insertion sort на малых)

---

## Что такое quick sort
Quick sort — сортировка по принципу “разделяй и властвуй”:
- выбирается опорный элемент `pivot`
- массив разбивается на части относительно `pivot`
- рекурсивно сортируются части

---

## Свойства quick sort

### Стабильность
❌ **Нестабильная** в большинстве in-place реализаций: равные элементы могут поменяться местами.

### In-place
- Вариант 1 (медленный): ❌ не in-place (создаёт новые списки)
- Вариант 2 (обычный): ✅ in-place
- Вариант 3 (оптимизированный): ✅ in-place

### Сложность по времени
| Случай | Время | Когда |
|------|------|------|
| Лучший | `O(n log n)` | разбиение близко к равным частям |
| Средний | `O(n log n)` | “в среднем” при хорошем выборе pivot |
| Худший | `O(n^2)` | pivot каждый раз почти крайний (плохие разбиения) |

### Память
- Вариант 1: `O(n)`+ (создание новых списков на каждом уровне рекурсии)
- Вариант 2: `O(log n)` в среднем (стек рекурсии), до `O(n)` в худшем
- Вариант 3: `O(log n)` (небольшой стек отрезков), рекурсии нет

---

## Почему 3-way partition (Dutch National Flag)
Разбиение на 3 части:
- `< pivot`
- `== pivot`
- `> pivot`

Плюсы:
- очень быстро на массивах с большим количеством одинаковых элементов
- уменьшает глубину рекурсии
- снижает вероятность “плохого” поведения по сравнению с 2-way partition

---

## Вариант 1 — “медленный” (left / mid / right)

### Идея
Создаёт 3 новых списка:
- `left`  — элементы меньше pivot
- `mid`   — равные pivot
- `right` — больше pivot

И возвращает `quick_sort(left) + mid + quick_sort(right)`.

### Почему медленный
- создаёт много новых списков (много аллокаций и копирований)
- память растёт, время на сборку результата тоже

### Сложность
- Время: среднее `O(n log n)`, худшее `O(n^2)`
- Память: **`O(n)`+** (из-за постоянного создания списков)

### Когда полезен
- для объяснения идеи quick sort (самый наглядный)
- для маленьких `n`

---

## Вариант 2 — “обычный” (in-place, 3 группы, pivot по центру)

### Идея
Работает “на месте” на отрезке `[l, r)` и разбивает на 3 группы:
- `a[l:i)`  — `< pivot`
- `a[i:j)`  — `== pivot`
- `a[j:r)`  — `> pivot`

Pivot выбирается детерминированно:
`pivot = a[(l + r) // 2]`.

### Плюсы
- не создаёт новые массивы
- хорошо работает при наличии повторов (3-way partition)
- понятнее, чем “супероптимизированная”, но уже близко к боевой

### Минусы
- в некоторых специально подобранных входах pivot по центру может давать плохие разбиения → `O(n^2)`
- рекурсия: при плохих разбиениях может быть глубокой

### Сложность
- Время: среднее `O(n log n)`, худшее `O(n^2)`
- Память: среднее `O(log n)` (стек), худшее `O(n)`

---

## Вариант 3 — “максимально оптимизированный” (median-of-three)

### Что оптимизировано
1) **Pivot = median-of-three**  
   Опорный элемент берётся как медиана из трёх значений: `a[l]`, `a[mid]`, `a[r-1]`.  
   Это дешевле рандома и обычно даёт более “здоровые” разбиения, чем просто центр, особенно на частично отсортированных входах.

2) **3-way partition (Dutch National Flag)**  
   Быстро на повторяющихся значениях.

3) **Итеративная реализация (стек отрезков)**  
   Без рекурсии → нет риска переполнения стека.

4) **Гибрид с insertion sort на маленьких кусках**  
   Квиксорт режет только большие куски.  
   Когда все куски стали маленькими (≤ порога), выполняется **один insertion sort по всему массиву** — он быстро добивает “почти отсортированное” состояние.

5) **Оптимизация стека**  
   “Больший кусок” кладётся в стек, “меньший” обрабатывается сразу → стек маленький (`O(log n)`).

### Сложность
- Время: среднее `O(n log n)` (обычно быстрее варианта 2 на практике)
- Худший случай теоретически остаётся `O(n^2)` (как у quick sort в целом)
- Память: `O(log n)` (стек отрезков)

---

## Что выбирать
- **Нужно объяснить идею** → вариант 1
- **Нужно нормальное решение для задач** → вариант 2
- **Нужно максимально “боевое” решение** → вариант 3

---

## Важный практический комментарий
В реальных языках/библиотеках quick sort часто используют в гибридном виде
(median-of-three/рандомизация + 3-way partition + insertion sort на малых размерах),
потому что это даёт хорошую скорость на практике при сохранении простоты.
