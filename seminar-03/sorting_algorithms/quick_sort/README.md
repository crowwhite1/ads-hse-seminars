# Quick Sort (быстрая сортировка)

В этой папке — 3 реализации quick sort разной “серьёзности”:
1) **Медленная** (функциональный стиль: `left/mid/right`)
2) **Обычная** (in-place + 3-путевое разбиение, pivot детерминированный по центру)
3) **Максимально оптимизированная** (рандомный pivot + 3-way partition + итеративно + один insertion sort в конце)

---

## Что такое quick sort
Quick sort — сортировка по принципу “разделяй и властвуй”:
- выбирается опорный элемент `pivot`
- массив разбивается на части относительно `pivot`
- сортировка вызывается рекурсивно/итеративно для полученных частей

---

## Свойства quick sort

### Стабильность
❌ **Нестабильная** в большинстве in-place реализаций: равные элементы могут поменяться местами.

### In-place
- Вариант 1 (медленный): ❌ не in-place (создаёт новые списки)
- Вариант 2 (обычный): ✅ in-place
- Вариант 3 (оптимизированный): ✅ in-place

### Сложность по времени
| Случай | Время | Когда |
|------|------|------|
| Лучший | `O(n log n)` | разбиение близко к равным частям |
| Средний | `O(n log n)` | при “нормальном” выборе pivot |
| Худший | `O(n^2)` | pivot часто крайний (плохие разбиения) |

### Память
- Вариант 1: `O(n)`+ (создание новых списков на каждом уровне)
- Вариант 2: `O(log n)` в среднем (стек рекурсии), до `O(n)` в худшем
- Вариант 3: `O(log n)` (стек отрезков), рекурсии нет

---

## Почему 3-way partition (Dutch National Flag)
Разбиение на 3 части:
- `< pivot`
- `== pivot`
- `> pivot`

Плюсы:
- очень быстро на массивах с большим количеством одинаковых элементов
- уменьшает глубину рекурсии
- снижает вероятность “плохого” поведения по сравнению с 2-way partition

---

## Вариант 1 — “медленный” (left / mid / right)
### Идея
Создаёт 3 новых списка и возвращает:
`quick_sort(left) + mid + quick_sort(right)`.

### Минусы
- много аллокаций и копирований
- заметно хуже по памяти и скорости

---

## Вариант 2 — “обычный” (in-place, pivot по центру)
### Идея
Работает на отрезке `[l, r)` и разбивает массив на 3 группы:
- `a[l:i)`  — `< pivot`
- `a[i:j)`  — `== pivot`
- `a[j:r)`  — `> pivot`

Pivot выбирается детерминированно:
`pivot = a[(l + r) // 2]`.

---

## Вариант 3 — “максимально оптимизированный” (рандомный pivot)

### Что оптимизировано
1) **Pivot = random**  
   Pivot выбирается случайно на отрезке `[l, r)`.  
   Это сильно снижает вероятность худшего случая на специально подобранных тестах.

2) **3-way partition (Dutch National Flag)**  
   Особенно эффективно при большом количестве одинаковых элементов.

3) **Итеративная реализация (стек отрезков)**  
   Без рекурсии → нет риска переполнения стека.

4) **Гибрид с insertion sort**  
   Большие куски режутся quick sort'ом до размера `THRESHOLD`,  
   потом выполняется **один insertion sort по всему массиву**, который быстро добивает почти отсортированный массив.

5) **Оптимизация стека**  
   Больший кусок кладётся в стек, меньший обрабатывается сразу → стек остаётся маленьким (`O(log n)`).

---

## Что выбирать
- **Нужно объяснить идею** → вариант 1
- **Нужно нормальное решение для задач** → вариант 2
- **Нужно максимально “боевое” решение** → вариант 3

---

## Практический комментарий
В реальных реализациях quick sort часто используют гибрид:
рандомизация/median-of-three + 3-way partition + insertion sort на малых размерах,
потому что это даёт хорошую скорость на практике при сохранении простоты.
