# C. Доска для дипломов (бинпоиск по ответу)

Даны прямоугольники одинакового размера `w × h` (дипломы), всего `n` штук.  
Нужно найти **минимальную** сторону квадрата `S`, чтобы в квадрат `S × S` можно было разместить все `n` дипломов:

- каждый диплом размещается строго как `w × h` (без поворота на 90°),
- дипломы не перекрываются,
- размещение в виде сетки: по ширине помещается `⌊S / w⌋`, по высоте `⌊S / h⌋`.

Искомое минимальное `S`.

---

## Идея решения

Проверка для фиксированного `S`:

`cnt(S) = floor(S / w) * floor(S / h)`

Если `cnt(S) ≥ n`, то квадрат со стороной `S` подходит.

Функция `cnt(S)` монотонно неубывает по `S`, значит можно сделать **бинпоиск по ответу**.

---

## Обоснование выбора правой границы бинарного поиска

В задаче требуется найти минимальный размер стороны квадратной доски `S`, такой что на ней можно разместить `n` дипломов размером `w × h` без поворота, то есть должно выполняться условие:

(S // w) * (S // h) ≥ n

Здесь:
- `S // w` — количество дипломов по ширине,
- `S // h` — количество дипломов по высоте.

### Проблема переполнения

В языках Java и C++ при использовании 64-битных целых чисел (`long`, `long long`) возможно переполнение, если взять слишком большую правую границу бинарного поиска (например, `10^18`), поскольку произведение  
`(S // w) * (S // h)`  
может превысить максимальное значение типа.

### Как выбирается безопасная правая граница

Заметим, что в худшем случае:
- `n ≤ 10^9` (по условию),
- достаточно найти такое `S`, при котором можно разместить `10^9` дипломов.

Чтобы избежать переполнений, заменим `w` и `h` в выражении на `max(w, h)` — это уменьшит левую часть неравенства:

`(S // max(w, h)) * (S // max(w, h)) ≥ n`

Отсюда получаем:

`S² ≥ n * max(w, h)²`
`S ≥ √n * max(w, h)`

Так как `√(10^9) ≈ 31623`, можно взять заведомо безопасную и простую оценку сверху:

`S = 100000 * max(w, h)`

Эта граница:
- гарантированно достаточна для ответа,
- не приводит к переполнению при вычислениях,
- позволяет бинарному поиску работать быстро и корректно.

### Итог

В качестве правой границы бинарного поиска используется:

`r = 100000 * max(w, h)`

Это значение:
- минимально достаточное,
- безопасное по переполнениям,
- удобное для реализации на Python, Java и C++.

---

## Важное про переполнение (Java/C++)

Нельзя писать в лоб:
`(m / w) * (m / h) >= n`
потому что даже при m ~ 1e14 частные могут быть порядка 1e14, произведение — 1e28, это переполняет int64.

## Оценка скорости работы алгоритма

В решении используется **бинарный поиск по ответу**.

### Временная сложность

Бинарный поиск работает за `O(log R)`, где `R` — правая граница поиска.

В нашей задаче:
- `R = 100000 * max(w, h)`
- `w, h ≤ 10^9`, значит `R` порядка `10^14`

Следовательно:
- `log2(R) ≈ 47`

То есть алгоритм выполняет **менее 50 итераций** бинарного поиска.

На каждой итерации выполняется **константное число операций**:
- два целочисленных деления,
- одно умножение,
- одно сравнение.

Итоговая временная сложность:

O(log R) ≈ O(50) → фактически **O(1)**

### Пространственная сложность

Алгоритм использует только несколько переменных (`l`, `r`, `m`, `w`, `h`, `n`), поэтому:

- **Память: O(1)**

### Практический вывод

- Алгоритм работает **очень быстро**, даже при максимальных значениях входных данных.

Именно поэтому бинарный поиск по ответу является оптимальным и надёжным решением для данной задачи.

