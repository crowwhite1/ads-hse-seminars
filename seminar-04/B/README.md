# Приближённый бинарный поиск (closest element)

Дан отсортированный по неубыванию массив `A` (размер `N`) и массив запросов `B` (размер `K`).
Для каждого `x` из `B` нужно вывести элемент массива `A`, который **наиболее близок** к `x`.

Если ближайших несколько (одинаковая дистанция), нужно вывести **меньший** из них.

---

## Идея решения

Так как `A` отсортирован, для каждого запроса `x` можно найти ближайшие кандидаты через два бинарных поиска:

- `l = lbound(x)` — индекс **первого** элемента `A[l] >= x`
- `r = rbound(x)` — индекс **последнего** элемента `A[r] <= x`

Дальше случаи:

1) **x есть в A**  
   Тогда существует хотя бы одно вхождение и `l <= r`.  
   Можно сразу вывести `x`.

2) **x нет в A** (`l > r`)  
   Тогда ближайшие кандидаты — соседи вокруг позиции вставки:
   - `A[r]` — ближайший слева (меньше `x`)
   - `A[l]` — ближайший справа (больше `x`)

   Граничные случаи:
   - если `l == N`, справа нет → ответ `A[r]` (последний элемент)
   - если `r == -1`, слева нет → ответ `A[l]` (первый элемент)

   Иначе сравниваем расстояния:
   - `dr = A[l] - x`
   - `dl = x - A[r]`

   Если `dr < dl`, берём `A[l]`, иначе берём `A[r]`.  
   При равенстве (`dr == dl`) выбираем `A[r]`, потому что он **меньше**.

---

## Почему это работает быстро

Каждый запрос обрабатывается за `O(log N)`.

Итоговая сложность:
- Время: `O((N + K) + K log N)` (чтение + K запросов)
- Память: `O(N + K)` на хранение массивов
