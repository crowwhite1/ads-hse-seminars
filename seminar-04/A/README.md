# Поиск первого и последнего вхождения (binary search: lower/upper bound)

Даны два списка чисел:
- `A` длины `n`, **отсортирован по неубыванию**
- `B` длины `m`

Для каждого числа `x` из `B` нужно найти:
- позицию **первого** вхождения `x` в `A`
- позицию **последнего** вхождения `x` в `A`

Нумерация в ответе **с 1**.  
Если `x` не встречается в `A`, вывести `0`.

---

## Идея решения

Так как `A` отсортирован, для каждого запроса `x` можно сделать два бинарных поиска:

### 1) `lbound(x)` — lower bound
Находим **первый индекс** `l`, такой что `A[l] >= x`.

### 2) `rbound(x)` — right bound (в стиле задачи)
Находим **последний индекс** `r`, такой что `A[r] <= x`.
Это эквивалентно поиску первого `A[i] > x` и затем `r = i - 1`.

---

## Как понять, есть ли число в массиве

После двух поисков:

- если `l > r`, значит вхождений нет → печатаем `0`
- иначе печатаем `l+1 r+1` (переходим к 1-based индексам)

---

## Сложность

Для каждого запроса: `O(log n)`  
Всего: `O(m log n)` по времени  
Память: `O(1)` (кроме хранения массивов)

---

## Важные детали

- Работает корректно при повторяющихся элементах в `A`.
- Индексы в коде считаются с 0, в ответе выводим с 1.
