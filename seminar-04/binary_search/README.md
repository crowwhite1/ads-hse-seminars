# Бинарный поиск: lbound / rbound (левая и правая границы)

Эта папка содержит 2 классических функции бинарного поиска для **отсортированного по неубыванию массива**:

- `lbound(x)` — индекс первого элемента `>= x` (left / lower bound)
- `rbound(x)` — индекс последнего элемента `<= x` (right bound в стиле задач)

Эти функции особенно полезны для задач на:
- поиск первого/последнего вхождения числа,
- подсчёт количества элементов в диапазоне,
- “позицию вставки”,
- приближённый поиск ближайшего элемента.

---

## Предусловие

Массив `a` должен быть **отсортирован по неубыванию**.

Индексация в коде — **с 0**.

---

## lbound(x) — первая позиция, где можно поставить x

Функция возвращает минимальный индекс `r`, такой что:

a[r] >= x

Если все элементы меньше `x`, то ответ будет `n` (позиция “после массива”).

### Что возвращает

- диапазон результата: `[0 .. n]`
- `0` — если уже `a[0] >= x`
- `n` — если `a[i] < x` для всех `i`

---

## rbound(x) — последняя позиция элемента ≤ x

Функция возвращает максимальный индекс `l`, такой что:

a[l] <= x

Если все элементы больше `x`, то ответ будет `-1`.

### Что возвращает

- диапазон результата: `[-1 .. n-1]`
- `-1` — если `a[0] > x`
- `n-1` — если `a[n-1] <= x`

---

## Почему в коде такие границы: l = -1, r = n

Мы храним два указателя на “границы области истины/лжи”:

- `l` — индекс, который точно НЕ подходит
- `r` — индекс, который потенциально подходит (или наоборот, в зависимости от условия)

Для `lbound` поддерживается инвариант:

- `a[l] < x` (для l = -1 считаем это истинным “виртуально”)
- `a[r] >= x` (для r = n считаем это истинным “виртуально”)

За счёт таких “виртуальных” границ:
- код единый и для случаев “x меньше всех” и “x больше всех”
- нет отдельных if’ов по краям
- ответ всегда получается корректно

Цикл продолжается, пока между `l` и `r` есть хотя бы один индекс:

while (r - l > 1)

---

## Как использовать вместе

### 1) Проверить, есть ли x в массиве
Пусть:
- `L = lbound(x)`
- `R = rbound(x)`

Тогда `x` встречается в массиве тогда и только тогда, когда:

L <= R

---

### 2) Найти первое и последнее вхождение x
Если `L <= R`, то:
- первое вхождение: `L`
- последнее вхождение: `R`

---

### 3) Количество вхождений x
Если `L <= R`, то количество:

R - L + 1

Иначе `0`.

---

## Сложность

Каждая функция выполняет бинарный поиск:

- Время: `O(log n)`
- Память: `O(1)`

---

## Файлы

- `BinarySearchBounds.java` — реализации для Java
- `binary_search_bounds.cpp` — реализации для C++
- `binary_search_bounds.py` — реализации для Python
