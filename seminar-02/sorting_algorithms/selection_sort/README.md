# Selection Sort (Сортировка выбором)

## Идея алгоритма
Selection sort строит отсортированную часть массива слева направо:
на шаге `i` находит **минимальный элемент** на отрезке `[i..n-1]` и **меняет местами**
его с `a[i]`.

---

## Псевдокод
1. Для `i` от `0` до `n-1`:
   - `minPos = i`
   - для `j` от `i+1` до `n-1`:
     - если `a[j] < a[minPos]`, то `minPos = j`
   - swap(`a[i]`, `a[minPos]`)

---

## Свойства алгоритма

### ❌ Устойчивость (Stability)
**Selection sort обычно неустойчивый**: из-за обмена `a[i]` с найденным минимумом
равные элементы могут поменяться местами.

---

### ✅ Сложность по времени
Selection sort всегда делает почти одинаковое число сравнений, независимо от входа.

| Случай | Время |
|------|------|
| Лучший | **O(n²)** |
| Средний | **O(n²)** |
| Худший | **O(n²)** |

---

### ✅ Сложность по памяти
**O(1)** — сортировка на месте (in-place).

---

## Обмены (swap) — ключевая особенность
Selection sort делает **минимально возможное количество обменов** среди простых сортировок:
- максимум **n-1 swap** (по одному на позицию)

Это полезно, когда:
- swap дорогой (например, запись во внешнюю память),
- но сравнения дешёвые.

---

## Когда selection sort использовать?
### Можно / хорошо подходит:
- маленькие массивы
- когда важно минимизировать количество обменов

### Не стоит:
- большие массивы (O(n²))
- когда нужна устойчивость

---

## Итог
Selection sort:
- ✅ простой
- ✅ in-place, O(1) память
- ✅ мало обменов (≤ n-1)
- ❌ всегда O(n²)
- ❌ неустойчивый
