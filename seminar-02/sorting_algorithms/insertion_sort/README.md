# Insertion Sort (Сортировка простыми вставками)

## Идея алгоритма
Insertion sort поддерживает **отсортированную часть массива слева** и по одному
вставляет следующий элемент (`key`) на правильное место в этой отсортированной части,
сдвигая вправо все элементы, которые больше `key`.

Интуитивно: как сортировка карт в руке — берём очередную карту и вставляем её в нужную позицию.

---

## Псевдокод
1. Для `i` от `1` до `n-1`:
   - `key = a[i]`
   - `j = i-1`
   - пока `j >= 0` и `a[j] > key`:
     - сдвинуть `a[j]` вправо (`a[j+1] = a[j]`)
     - `j--`
   - поставить `key` в `a[j+1]`

---

## Свойства алгоритма

### ✅ Устойчивость (Stability)
**Insertion sort устойчивый**, если сравнение строгое `>`:
- равные элементы не “перепрыгивают” друг через друга
- их относительный порядок сохраняется

---

### ✅ Сложность по времени
| Случай | Время | Когда |
|------|------|------|
| Лучший | **O(n)** | массив уже отсортирован (почти нет сдвигов) |
| Средний | **O(n²)** | случайный массив |
| Худший | **O(n²)** | обратный порядок (каждый элемент “уезжает” в начало) |

---

### ✅ Сложность по памяти
**O(1)** — сортировка на месте (in-place), используется только несколько переменных.

---

### Важная особенность: отлично работает на почти отсортированных массивах
Если массив почти отсортирован, количество сдвигов маленькое, и insertion sort
может быть очень быстрым (близко к O(n)).

---

## Когда insertion sort использовать?
### Можно / хорошо подходит:
- маленькие `n`
- почти отсортированные данные
- как часть гибридных сортировок (например, в TimSort для маленьких “ранов”)

### Не стоит:
- большие случайные массивы (O(n²) будет слишком медленно)

---

## Итог
Insertion sort:
- ✅ простой
- ✅ устойчивый (при условии `>`)
- ✅ in-place, O(1) память
- ✅ быстрый на почти отсортированных данных
- ❌ O(n²) в среднем/худшем случае
