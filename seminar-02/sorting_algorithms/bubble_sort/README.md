# Bubble Sort (Сортировка пузырьком)

## Идея алгоритма
Bubble sort — простой алгоритм сортировки, который многократно проходит по массиву
и **меняет местами соседние элементы**, если они стоят в неправильном порядке.
Из-за этих «всплывающих» обменов большие элементы постепенно «всплывают» вправо.

Оптимизированная версия использует **флаг**: если за один проход не было ни одного обмена,
значит массив уже отсортирован и можно завершить работу раньше.

---

## Псевдокод (оптимизированный)
1. Для `i` от `0` до `n-2`:
   - `swapped = false`
   - Для `j` от `0` до `n-2-i`:
     - если `a[j] > a[j+1]`, то обменять и `swapped = true`
   - если `swapped == false`, завершить

---

## Свойства алгоритма

### ✅ Устойчивость (Stability)
**Bubble sort устойчивый**, если обмен выполняется только при строгом `>`:
- одинаковые элементы (`a[j] == a[j+1]`) **не меняются местами**
- значит их относительный порядок сохраняется

⚠️ Если использовать `>=`, устойчивость потеряется.

---

### ✅ Сложность по времени
Обозначим `n` — количество элементов.

| Случай | Время | Когда |
|------|------|------|
| Лучший | **O(n)** | массив уже отсортирован (из-за раннего выхода) |
| Средний | **O(n²)** | случайный массив |
| Худший | **O(n²)** | массив отсортирован в обратном порядке |

---

### ✅ Сложность по памяти
**O(1)** — сортировка выполняется на месте (in-place), дополнительная память почти не используется.

---

### ✅ Количество обменов и сравнений
- В худшем случае обменов может быть **O(n²)** (пример: обратный порядок)
- Сравнений в классической реализации: примерно `n(n-1)/2`

---

## Когда bubble sort использовать?
### Можно:
- для обучения
- когда `n` маленькое
- когда важна простота и прозрачность кода

### Не стоит:
- для больших массивов (очень медленно)
- в продакшене почти всегда есть сортировки быстрее (QuickSort / MergeSort / TimSort)

---

## Итог
Bubble sort:
- ✅ простой
- ✅ устойчивый (при условии `>`)
- ✅ in-place
- ❌ медленный: O(n²) почти всегда
- ✅ можно ускорить ранним выходом (флаг)
